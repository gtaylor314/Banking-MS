package domain

import (
	"strconv"

	"github.com/gtaylor314/Banking-MS/errs"
	"github.com/gtaylor314/Banking-MS/logger"

	"github.com/jmoiron/sqlx"
)

// AccountRepositoryDb is an adapter that implements the AccountRepository (port) interface
type AccountRepositoryDb struct {
	db_conn *sqlx.DB
}

// Save() takes an account object (without an account_id), inserts the account into the accounts table and updates the account
// object with the account_id auto-incremented when the account was inserted
func (a AccountRepositoryDb) Save(acct Account) (*Account, *errs.AppError) {
	// define the SQL Insert command - accounts is the name of the table in our banking db
	sqlInsertCmd := "INSERT INTO accounts (customer_id, opening_date, account_type, amount, status) values (?, ?, ?, ?, ?)"

	// Exec() executes a db query/command without returning any rows
	result, err := a.db_conn.Exec(sqlInsertCmd, acct.CustomerID, acct.OpeningDate, acct.AccountType, acct.Amount, acct.Status)
	if err != nil {
		logger.Error("error while creating new account" + err.Error())
		return nil, errs.UnexpectedErr("unexpected database error during account creation")
	}
	// LastInsertId() returns the integer generated by the database in response to a command - in our case, the account_id
	// which auto-increments upon inserting a row
	acctID, err := result.LastInsertId()
	if err != nil {
		logger.Error("error retrieving account ID" + err.Error())
		return nil, errs.UnexpectedErr("unexpected database error retrieving account ID")
	}
	// FormatInt() returns the string representation of the passed in int64 value using the given base (in this case
	// base 10 for decimal)
	acct.AccountID = strconv.FormatInt(acctID, 10)
	return &acct, nil
}

// NewAccountRepositoryDb() will take in a db connection and create an AccountRepositoryDb which it then returns
func NewAccountRepositoryDb(db_conn *sqlx.DB) AccountRepositoryDb {
	return AccountRepositoryDb{db_conn: db_conn}
}
